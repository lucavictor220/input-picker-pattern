<link rel="import" href="input-shared-style.html">
<link rel="import" href="dropdown-tip-style.html">
<link rel="import" href="form-element-mixin.html">

<script>
  /**
   * mixin to extend an element with a test for an expected input type and implement a polyfill, when wanted or needed
   *
   * @appliesMixin FormElementMixin
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--input-color` | text-color of the element | `#dadada`
   * `--input-background` | text-color of the element | `#2b2b2b`
   * `--input-focus-color` | color of the focussed or hovered inputs and icons | `#f5f5f5`
   * `--input-focus-background` | background of the focussed or hovered inputs and icons | `--primary-color, #394FE8`
   * `--input-style` | Mixin applied to the inputs | { border-radius: 3px; padding: 0.2em 0.1em; border: none; outline: none; text-align: center; color: inherit; cursor: pointer; background: transparent; box-sizing: content-box; transition: background 150ms cubic-bezier(0.6, 1, 0.2, 1);`
   * `--input-focus` | Mixin applied to the focussed or hovered inputs | {}`
   * `--input-icon` | Mixin applied to the icons | `{border-radius: 2px; padding: 8px; height: 16px; width: 16px; background: transparent; transition: background 150ms cubic-bezier(0.6, 1, 0.2, 1); cursor: pointer; fill: currentColor; }`
   * `--input-picker` | Mixin applied to the element | `{box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 1px 8px 0 rgba(0, 0, 0, 0.12), 0 3px 3px -2px rgba(0, 0, 0, 0.4); border-radius: 4px;}`
   *
   * @mixinFunction
   * @polymer
   */
  const InputPickerPattern = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends FormElementMixin(superClass) { // eslint-disable-line no-undef
      /**
       * the expected input type, that should be polyfilled, if not available
       * @type {string}
       */
      static get expectedNativeInputType() {
        return 'text';
      }

      /**
       * test `expectedNativeInputType`, if that native input is supported
       * @type {string}
       */
      static get hasNative() {
        const inputDate = document.createElement('input');
        inputDate.setAttribute('type', `${this.expectedNativeInputType}`);
        this._hasNative = inputDate.type === `${this.expectedNativeInputType}`;
        return this._hasNative;
      }

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.hasNative ? this.nativeTemplate : this.polyfillTemplate}
        `
      }

      /**
       * custom style template
       * @type {string}
       */
      static get styleTemplate() {
        return `
          <style include="${this.customStyleToInclude || ''}">
            ${this.customStyleContent}
          </style>
        `;
      }

      /**
       * custom style to include in `<style include="..."`
       * @type {string}
       */
      static get customStyleToInclude() {
        return `${super.customStyleToInclude || ''} input-shared-style dropdown-tip-style`;
      }

      /**
       * custom style content
       * @type {string}
       */
      static get customStyleContent() {
        return `
          ${super.customStyleContent || ''}
          :host {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            position: relative;
          }
          #polyfill {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            @apply --input-style;
            padding: 0;
          }
          :host(:hover) #polyfill,
          :host(:focus) #polyfill {
            @apply --input-focus;
          }
          #polyfill > .replacement {
            --input-color: currentColor;
            --input-background: transparent;
          }
          #picker {
            display: inline-block;
            color: var(--input-color);
            background: var(--input-background);
            @apply --input-picker;
            padding: 0;
          }
          #picker #buttons {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            position: relative;
            align-self: flex-end;
            align-items: center;
            justify-content: flex-end;
            color: var(--input-color);
            background: var(--input-background);
          }
          #picker > * {
            padding: var(--input-picker-padding, 4px);
            box-shadow: none !important;
            box-sizing: border-box;
            float: left;
            clear: both;
            width: 100%;
          }
          #picker > :first-child {
            border-top-left-radius: inherit;
            border-top-right-radius: inherit;
          }
          #picker > :not(:first-child) {
            border-top-left-radius: 0 !important;
            border-top-right-radius: 0 !important;
          }
          #picker > :not(:last-child) {
            border-bottom-left-radius: 0 !important;
            border-bottom-right-radius: 0 !important;
          }
          #picker > :last-child {
            padding-top: 0;
            border-bottom-left-radius: inherit;
            border-bottom-right-radius: inherit;
          }
        `;
      }

      /**
       * template for native input is supported including the polyfill
       * @type {string}
       */
      static get nativeTemplate() {
        return `
          ${this.nativeInputTemplate}
          <div hidden$="[[native]]" style="position:relative;">
            ${this.polyfillTemplate}
          </div>
        `
      }

      /**
       * template for polyfilled input and picker
       * @type {string}
       */
      static get polyfillTemplate() {
        return `
          <div id="polyfill" on-click="open">
            ${this.polyfillInputTemplate}
          </div>
          ${this.pickerTemplate}
        `;
      }

      /**
       * template for control buttons
       * @type {string}
       */
      static get buttonTemplate() {
        return `
          ${super.buttonTemplate || ''}
          <button class="icon confirm" on-click="confirm" on-keydown="_stopPropagation">${this._iconConfirmTemplate}</button>
          <button class="icon cancel" on-click="cancel" on-keydown="_stopPropagation" hidden$="[[autoConfirm]]">${this._iconCloseTemplate}</button>
        `;
      }

      static get _iconCloseTemplate() {
        return '<svg viewBox="0 0 24 24"><g><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></g></svg>';
      }

      static get _iconConfirmTemplate() {
        return '<svg viewBox="0 0 24 24"><g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></g></svg>';
      }

      /**
       * template for native input element
       * @type {string}
       */
      static get nativeInputTemplate() {
        return `
          <input class="native" type="${this.expectedNativeInputType}" hidden$="[[!native]]" disabled$="[[disabled]]" readonly="[[disabled]]" required="[[required]]" value="{{${this.nativeInputBinding || this.expectedNativeInputType}::input}}">
        `;
      }

      /**
       * template for the replacement of the native input elements
       * @type {string}
       */
      static get polyfillInputTemplate() {
        return '';
      }

      /**
       * template for the picker
       * @type {string}
       */
      static get pickerTemplate() {
        return `
          <div id="picker" class="dropdown">
            <div id="buttons">
              ${this.buttonTemplate}
            <div>
          </div>`;
      }

      static get properties() {
        return {
          /**
           * use the native input, if it exists
           */
          native: {
            type: Boolean,
            value: false
          },

          /**
           * use the native input automatically on mobile devices
           */
          nativeOnMobile: {
            type: Boolean,
            value: false,
            observer: '_nativeOnMobileChanged'
          },

          /**
           * opens the picker
           */
          opened: {
            type: Boolean,
            reflectToAttribute: true,
            value: false,
            notify: true
          },

          /**
           * The orientation against which to align the element horizontally
           * relative to the related input element. Possible values are "left", "right", "center", "auto". (comparable to `iron-fit-behavior` and its `no-overlap`-attribute)
           */
          horizontalAlign: {
            type: String,
            reflectToAttribute: true,
            value: 'auto'
          },

          /**
           * The orientation against which to align the element vertically
           * relative to the related input element. Possible values are "top", "bottom", "middle", "auto". (comparable to `iron-fit-behavior` and its `no-overlap`-attribute)
           */
          verticalAlign: {
            type: String,
            reflectToAttribute: true,
            value: 'auto'
          },

          /**
           * Set to true to make the input auto-confirming
           */
          autoConfirm: {
            type: Boolean,
            value: false
          },

          /**
           * Set to true to disable canceling the overlay with the ESC key.
           */
          noCancelOnEscKey: {
            type: Boolean,
            value: false
          },

          /**
           * Set to true to disable canceling the dropdown by clicking outside the picker.
           */
          noCancelOnOutsideClick: {
            type: Boolean,
            value: false
          },

          /**
           * Set to true to keep multiple pickers open. (will only work as expected when e.g. `noCancelOnOutsideClick` is set to true)
           */
          keepMultiplePickersOpen: {
            type: Boolean,
            value: false
          },

          /**
           * Set to true to disable the tip of the picker
           */
          noTip: {
            type: Boolean,
            reflectToAttribute: true
          }

          /**
          * @event input-picker-opened
          * Fired when a picker has been opened.
          */

          /**
          * @event input-picker-closed
          * Fired after a picker has been closed.
          */
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this._onPickerTransitionEnd = this._onPickerTransitionEnd.bind(this);
        this._checkKeycode = this._checkKeycode.bind(this);
        this._stopPropagation = this._stopPropagation.bind(this);
        this.cancel = this.cancel.bind(this);
        this._addPickerTransitionEndListener();
        this._addKeyListener();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removePickerTransitionEndListener();
        this._removeKeyListener();
      }

      _addPickerTransitionEndListener() {
        if (!this.opened) {
          // enshure display style for the picker, for ignoring the tabindex of the picker elements
          this.$.picker.style.visibility = 'hidden';
          this.$.picker.style.display = 'hidden';
        }
        this.$.picker.addEventListener('transitionend', this._onPickerTransitionEnd, false);
      }

      _removePickerTransitionEndListener() {
        this.$.picker.removeEventListener('transitionend', this._onPickerTransitionEnd, false);
      }

      _onPickerTransitionEnd() {
        if (!this.opened) {
          this.$.picker.style.visibility = 'hidden';
          this.$.picker.style.display = 'hidden';
        }
      }

      _addCancelOnClickListener() {
        // prevent when clicking on the picker that it is closes
        if (!this.noCancelOnOutsideClick) {
          document.addEventListener('click', this.cancel, false);
          this.addEventListener('click', this._stopPropagation, false);
        }
      }

      _removeCancelOnClickListener() {
        document.removeEventListener('click', this.cancel, false);
        this.removeEventListener('click', this._stopPropagation, false);
      }

      _addKeepPickersOpenListener() {
        if (!this.keepMultiplePickersOpen) {
          document.addEventListener('input-picker-opened', this.cancel, false);
        }
      }

      _removeKeepPickersOpenListener() {
        document.removeEventListener('input-picker-opened', this.cancel, false);
      }

      _stopPropagation(e) {
        e && e.stopPropagation();
      }

      _addKeyListener() {
        super._addKeyListener && super._addKeyListener();
        this.addEventListener('keydown', this._checkKeycode, false);
      }

      _removeKeyListener() {
        super._removeKeyListener && super._removeKeyListener();
        this.removeEventListener('keydown', this._checkKeycode, false);
      }

      _nativeOnMobileChanged(nativeOnMobile) {
        if (nativeOnMobile === undefined) {
          return;
        }

        const ua = window.navigator.userAgent,
          isMobile = /[mM]obi/i.test(ua) || /[tT]ablet/i.test(ua) || /[aA]ndroid/i.test(ua);
        if (isMobile === true) {
          if (nativeOnMobile === true) {
            this.native = true;
          } else if (!this.native && nativeOnMobile === false) {
            this.native = false;
          }
        }
      }

      /**
       * key press event handler
       * @param  {[type]} e Event
       */
      _checkKeycode(e) {
        if (!e) {
          return;
        }
        if (e.keyCode === 27 && !this.noCancelOnEscKey) { // esc
          this.cancel();
          return;
        }
        if (e.keyCode === 13 || e.keyCode === 32) { // space || enter
          if (this.opened) {
            this.confirm();
          } else {
            this.open();
          }
          return;
        }
        if (super._checkKeycode) {
          super._checkKeycode(e);
        }
      }

      /**
       * open the picker
       */
      open(e) {
        if (e && e.stopPropagation) {
          e.stopPropagation();
        }
        this.$.picker.style.display = '';
        this.$.picker.style.visibility = '';
        if (super.open) {
          super.open();
        }
        if (!this.opened) {
          this.dispatchEvent(new (CustomEvent || Event)('input-picker-opened', { bubbles: true, detail: this }));
          setTimeout(() => {
            this._addCancelOnClickListener();
            this._addKeepPickersOpenListener();
          })
        }
        this.opened = true;
      }

      /**
       * close the picker
       * @param  {[type]} e Event
       */
      close(e) {
        if (e && e.stopPropagation) {
          e.stopPropagation();
        }
        this._removeCancelOnClickListener();
        this._removeKeepPickersOpenListener();
        if (super.close) {
          super.close();
        }
        setTimeout( () => {
          this.opened = false;
          this.dispatchEvent(new (CustomEvent || Event)('input-picker-closed', { bubbles: true, detail: this }));
        })
      }

      /**
       * toggle the picker
       * @param  {[type]} e Event
       */
      toggle(e) {
        if (e && e.stopPropagation) {
          e.stopPropagation();
        }
        if (super.toggle) {
          super.toggle();
        }
        this.opened = !this.opened;
      }

      /**
       * confirms the input
       * @param  {[type]} e Event
       */
      confirm(e) {
        if (e && e.stopPropagation) {
          e.stopPropagation();
        }
        if (super.confirm) {
          super.confirm();
        }
        this.close();
      }

      /**
       * cancels the input
       * @param  {[type]} e Event
       */
      cancel(e) {
        if (e && e.stopPropagation) {
          e.stopPropagation();
        }
        if (super.cancel) {
          super.cancel();
        }
        if (this.autoConfirm) {
          this.confirm();
        }
        this.close();
      }

    }
  }
</script>
